<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Y-lib: Core of Ylib</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Y-lib
   </div>
   <div id="projectbrief">Loadrunner libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Core of Ylib</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga690f251553b39fd4f31894826141b61a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga690f251553b39fd4f31894826141b61a">RAND_MAX</a>&#160;&#160;&#160;32767</td></tr>
<tr class="memdesc:ga690f251553b39fd4f31894826141b61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAND_MAX constant for use with <a class="el" href="vugen_8h.html#ae23144bcbb8e3742b00eb687c36654d1" title="Documented at http://www.cplusplus.com/reference/cstdlib/rand/. ">rand()</a> - 15 bits integer.  <a href="#ga690f251553b39fd4f31894826141b61a">More...</a><br /></td></tr>
<tr class="separator:ga690f251553b39fd4f31894826141b61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16db77ab873c5b767742a51c9613314b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga16db77ab873c5b767742a51c9613314b">Y_RAND_MAX</a>&#160;&#160;&#160;1073741823</td></tr>
<tr class="memdesc:ga16db77ab873c5b767742a51c9613314b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate RAND_MAX constant for use with y_rand.  <a href="#ga16db77ab873c5b767742a51c9613314b">More...</a><br /></td></tr>
<tr class="separator:ga16db77ab873c5b767742a51c9613314b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af77582aacd5cada48e9860f67d67e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga2af77582aacd5cada48e9860f67d67e1">vuser_init</a>()&#160;&#160;&#160;vuser_init() { <a class="el" href="group__core.html#ga7350ca6bb0383b2169ef4eaae3b091e7">y_setup</a>(); return y_vuser_init(); } y_vuser_init()</td></tr>
<tr class="memdesc:ga2af77582aacd5cada48e9860f67d67e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook to ensure that <a class="el" href="group__core.html#ga7350ca6bb0383b2169ef4eaae3b091e7" title="Ylib setup - determines and stores the identity of the virtual user. ">y_setup()</a> is called at start-up. This allows many performance improvements in the library.  <a href="#ga2af77582aacd5cada48e9860f67d67e1">More...</a><br /></td></tr>
<tr class="separator:ga2af77582aacd5cada48e9860f67d67e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed34897cb0a5fb0ae18cf0d6facc35b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaed34897cb0a5fb0ae18cf0d6facc35b5">y_is_vugen_run</a>()&#160;&#160;&#160;<a class="el" href="group__core.html#ga6946e1e353167a7a711e3ddcb8a39b6d">y_is_vugen_run_bool</a></td></tr>
<tr class="memdesc:gaed34897cb0a5fb0ae18cf0d6facc35b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this script is running in vugen (debug mode)  <a href="#gaed34897cb0a5fb0ae18cf0d6facc35b5">More...</a><br /></td></tr>
<tr class="separator:gaed34897cb0a5fb0ae18cf0d6facc35b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7350ca6bb0383b2169ef4eaae3b091e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga7350ca6bb0383b2169ef4eaae3b091e7">y_setup</a> ()</td></tr>
<tr class="memdesc:ga7350ca6bb0383b2169ef4eaae3b091e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ylib setup - determines and stores the identity of the virtual user.  <a href="#ga7350ca6bb0383b2169ef4eaae3b091e7">More...</a><br /></td></tr>
<tr class="separator:ga7350ca6bb0383b2169ef4eaae3b091e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0419985b32761cce3f5d75e6aad36f05"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga0419985b32761cce3f5d75e6aad36f05">y_rand</a> (void)</td></tr>
<tr class="memdesc:ga0419985b32761cce3f5d75e6aad36f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random (integer) number between 0 and Y_RAND_MAX (30 bit maxint).  <a href="#ga0419985b32761cce3f5d75e6aad36f05">More...</a><br /></td></tr>
<tr class="separator:ga0419985b32761cce3f5d75e6aad36f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga319710d6642f34a8ea51a1a9898869fc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga319710d6642f34a8ea51a1a9898869fc">y_drand</a> (void)</td></tr>
<tr class="memdesc:ga319710d6642f34a8ea51a1a9898869fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number between 0 &lt;= <a class="el" href="group__core.html#ga319710d6642f34a8ea51a1a9898869fc" title="Generate a random number between 0 &lt;= y_drand() &lt; 1. This supersedes y_rand().  Equal to Math...">y_drand()</a> &lt; 1. This supersedes <a class="el" href="group__core.html#ga0419985b32761cce3f5d75e6aad36f05" title="Generate a random (integer) number between 0 and Y_RAND_MAX (30 bit maxint). ">y_rand()</a>. <br />
Equal to Math.random in Java and JavaScript, Random.NextDouble in C#, etc. Better distribution of the random numbers over the range than by using <a class="el" href="group__core.html#ga0419985b32761cce3f5d75e6aad36f05" title="Generate a random (integer) number between 0 and Y_RAND_MAX (30 bit maxint). ">y_rand()</a> with modulo (%) &ndash; thus no skewed results.  <a href="#ga319710d6642f34a8ea51a1a9898869fc">More...</a><br /></td></tr>
<tr class="separator:ga319710d6642f34a8ea51a1a9898869fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b54880fd4fe004b3cb8141255c6474"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga71b54880fd4fe004b3cb8141255c6474">y_mem_alloc</a> (size_t size)</td></tr>
<tr class="memdesc:ga71b54880fd4fe004b3cb8141255c6474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ylib wrapper for <a class="el" href="group__memory.html#ga5f1a5df9b8c50bd259b8c34c0056e304" title="Documented at http://www.cplusplus.com/reference/cstdlib/malloc/. ">malloc()</a>  <a href="#ga71b54880fd4fe004b3cb8141255c6474">More...</a><br /></td></tr>
<tr class="separator:ga71b54880fd4fe004b3cb8141255c6474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084a530700465b1a7a10d103f2a2e6d4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga084a530700465b1a7a10d103f2a2e6d4">y_array_alloc</a> (size_t length, size_t size)</td></tr>
<tr class="memdesc:ga084a530700465b1a7a10d103f2a2e6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a character array and initializes all elements to zero As <a class="el" href="group__core.html#ga71b54880fd4fe004b3cb8141255c6474" title="Ylib wrapper for malloc() ">y_mem_alloc()</a>, but using the '<a class="el" href="group__memory.html#gae201ae1031fe85000b4e22abb3a824b2" title="Documented at http://www.cplusplus.com/reference/cstdlib/calloc/. ">calloc</a>' function, rather than '<a class="el" href="group__memory.html#ga5f1a5df9b8c50bd259b8c34c0056e304" title="Documented at http://www.cplusplus.com/reference/cstdlib/malloc/. ">malloc()</a>'.  <a href="#ga084a530700465b1a7a10d103f2a2e6d4">More...</a><br /></td></tr>
<tr class="separator:ga084a530700465b1a7a10d103f2a2e6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cba325c05b63bbbdc499702c4f5c6e9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga8cba325c05b63bbbdc499702c4f5c6e9">y_strdup</a> (char *source)</td></tr>
<tr class="memdesc:ga8cba325c05b63bbbdc499702c4f5c6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string into a <a class="el" href="group__memory.html#ga5f1a5df9b8c50bd259b8c34c0056e304" title="Documented at http://www.cplusplus.com/reference/cstdlib/malloc/. ">malloc</a>'d piece of memory using <a class="el" href="group__string.html#ga86e0df1bf9e434074f958434e0af7581" title="Documented at http://pubs.opengroup.org/onlinepubs/007904975/functions/strdup.html ...">strdup()</a>, and lr_abort() if the allocation fails. See the <a class="el" href="group__string.html#ga86e0df1bf9e434074f958434e0af7581" title="Documented at http://pubs.opengroup.org/onlinepubs/007904975/functions/strdup.html ...">strdup()</a> C documentation for what it does. This is just a simple wrapper around it that catches the strdup return value and handles any errors by aborting the script.  <a href="#ga8cba325c05b63bbbdc499702c4f5c6e9">More...</a><br /></td></tr>
<tr class="separator:ga8cba325c05b63bbbdc499702c4f5c6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab903d513f84dc0cd3f7af7acf67e2fb2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gab903d513f84dc0cd3f7af7acf67e2fb2">y_get_parameter_eval_string</a> (const char *param_name)</td></tr>
<tr class="memdesc:gab903d513f84dc0cd3f7af7acf67e2fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the string required to fetch the contents of a parameter through lr_eval_string().  <a href="#gab903d513f84dc0cd3f7af7acf67e2fb2">More...</a><br /></td></tr>
<tr class="separator:gab903d513f84dc0cd3f7af7acf67e2fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0778c8b8f3da732862ab82176857be8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gac0778c8b8f3da732862ab82176857be8">y_is_empty_parameter</a> (const char *param_name)</td></tr>
<tr class="memdesc:gac0778c8b8f3da732862ab82176857be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given parameter is empty or not yet set. (These are two different things..) It would be nice if loadrunner had a builtin for this.  <a href="#gac0778c8b8f3da732862ab82176857be8">More...</a><br /></td></tr>
<tr class="separator:gac0778c8b8f3da732862ab82176857be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8252a459f15c52a8680fff9ddbd7356c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga8252a459f15c52a8680fff9ddbd7356c">y_get_parameter</a> (const char *param_name)</td></tr>
<tr class="memdesc:ga8252a459f15c52a8680fff9ddbd7356c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the content of a parameter and return it as a char *.  <a href="#ga8252a459f15c52a8680fff9ddbd7356c">More...</a><br /></td></tr>
<tr class="separator:ga8252a459f15c52a8680fff9ddbd7356c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81efb56d5afc4806cdc79f64ba3d675"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaf81efb56d5afc4806cdc79f64ba3d675">y_get_parameter_or_null</a> (const char *param_name)</td></tr>
<tr class="memdesc:gaf81efb56d5afc4806cdc79f64ba3d675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the content of a parameter and return it as a char *, or return NULL if it wasn't set.  <a href="#gaf81efb56d5afc4806cdc79f64ba3d675">More...</a><br /></td></tr>
<tr class="separator:gaf81efb56d5afc4806cdc79f64ba3d675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0c6a383cf2934da4acc1451a1cdea21"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gac0c6a383cf2934da4acc1451a1cdea21">y_get_parameter_with_malloc_or_null</a> (const char *src_param)</td></tr>
<tr class="memdesc:gac0c6a383cf2934da4acc1451a1cdea21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the content of a parameter and return it as a char * (malloc version)  <a href="#gac0c6a383cf2934da4acc1451a1cdea21">More...</a><br /></td></tr>
<tr class="separator:gac0c6a383cf2934da4acc1451a1cdea21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80c4db4c75cdc0c03aad6f69b3dff3c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaa80c4db4c75cdc0c03aad6f69b3dff3c">y_get_parameter_ext</a> (const char *source_param)</td></tr>
<tr class="memdesc:gaa80c4db4c75cdc0c03aad6f69b3dff3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the content of a parameter and return it as a char * (lr_eval_string_ext() version)  <a href="#gaa80c4db4c75cdc0c03aad6f69b3dff3c">More...</a><br /></td></tr>
<tr class="separator:gaa80c4db4c75cdc0c03aad6f69b3dff3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga312065213820734af47b86c233a26c0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga312065213820734af47b86c233a26c0d">y_virtual_user_id</a> = 0</td></tr>
<tr class="memdesc:ga312065213820734af47b86c233a26c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual user id, as reported by lr_whoami().  <a href="#ga312065213820734af47b86c233a26c0d">More...</a><br /></td></tr>
<tr class="separator:ga312065213820734af47b86c233a26c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36fcd2d9a92671f11bfebf8b7bfa34ae"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga36fcd2d9a92671f11bfebf8b7bfa34ae">y_virtual_user_group</a> = NULL</td></tr>
<tr class="memdesc:ga36fcd2d9a92671f11bfebf8b7bfa34ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual user group, as reported by lr_whoami().  <a href="#ga36fcd2d9a92671f11bfebf8b7bfa34ae">More...</a><br /></td></tr>
<tr class="separator:ga36fcd2d9a92671f11bfebf8b7bfa34ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ebd23898db36692c02dd58d9649f4a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga1ebd23898db36692c02dd58d9649f4a1">y_scid</a></td></tr>
<tr class="memdesc:ga1ebd23898db36692c02dd58d9649f4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual user scid, as reported by lr_whoami().  <a href="#ga1ebd23898db36692c02dd58d9649f4a1">More...</a><br /></td></tr>
<tr class="separator:ga1ebd23898db36692c02dd58d9649f4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6946e1e353167a7a711e3ddcb8a39b6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga6946e1e353167a7a711e3ddcb8a39b6d">y_is_vugen_run_bool</a> = 0</td></tr>
<tr class="memdesc:ga6946e1e353167a7a711e3ddcb8a39b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean, true when running in Vugen. Not able to do this in pre-compile phase.  <a href="#ga6946e1e353167a7a711e3ddcb8a39b6d">More...</a><br /></td></tr>
<tr class="separator:ga6946e1e353167a7a711e3ddcb8a39b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga690f251553b39fd4f31894826141b61a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RAND_MAX&#160;&#160;&#160;32767</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RAND_MAX constant for use with <a class="el" href="vugen_8h.html#ae23144bcbb8e3742b00eb687c36654d1" title="Documented at http://www.cplusplus.com/reference/cstdlib/rand/. ">rand()</a> - 15 bits integer. </p>
<p>Loadrunner does not give you full C headers, so the 'RAND_MAX' #define from &lt;stdlib.h&gt; is missing. We define it here mostly for documentation, as we do not have access to the header files themselves and therefore cannot change this. </p><dl class="section author"><dt>Author</dt><dd>Floris Kraak </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00057">57</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2af77582aacd5cada48e9860f67d67e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define vuser_init</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;vuser_init() { <a class="el" href="group__core.html#ga7350ca6bb0383b2169ef4eaae3b091e7">y_setup</a>(); return y_vuser_init(); } y_vuser_init()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hook to ensure that <a class="el" href="group__core.html#ga7350ca6bb0383b2169ef4eaae3b091e7" title="Ylib setup - determines and stores the identity of the virtual user. ">y_setup()</a> is called at start-up. This allows many performance improvements in the library. </p>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00106">106</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaed34897cb0a5fb0ae18cf0d6facc35b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define y_is_vugen_run</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__core.html#ga6946e1e353167a7a711e3ddcb8a39b6d">y_is_vugen_run_bool</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if this script is running in vugen (debug mode) </p>
<dl class="section return"><dt>Returns</dt><dd>1 (true) if running in vugen, zero (false) otherwise.</dd></dl>
<p>Recommended practice: Use this to create script debugging code that will hit all of the functional code inside the script when run in Vugen, but the full (semi-randomized) realistic scenario when it runs as part of a load test.</p>
<dl class="section note"><dt>Note</dt><dd>This relies on the y_virtual_user_id_bool variable as an indication of where the script is running. Inside Vugen that variable should be -1; Otherwise, it contains a non-negative number. This can be manipulated to your advantage, but may break if HP ever changes that convention.</dd></dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;debug_clickflow()</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  do_stuff();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;loadtest_clickflow()</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;{</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   do_more_complicated_stuff();</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;Action()</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;{</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   if( y_is_vugen_run() )</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;      debug_clickflow();</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   else</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;      loadtest_clickflow();</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga7350ca6bb0383b2169ef4eaae3b091e7" title="Ylib setup - determines and stores the identity of the virtual user. ">y_setup()</a> </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00142">142</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga16db77ab873c5b767742a51c9613314b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Y_RAND_MAX&#160;&#160;&#160;1073741823</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate RAND_MAX constant for use with y_rand. </p>
<p><a class="el" href="group__core.html#ga0419985b32761cce3f5d75e6aad36f05" title="Generate a random (integer) number between 0 and Y_RAND_MAX (30 bit maxint). ">y_rand()</a> provides for a far bigger ceiling to the random number generator: 31 bits on Windows and 30 bits otherwise, instead of 15. </p><dl class="section author"><dt>Author</dt><dd>Floris Kraak </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00070">70</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga084a530700465b1a7a10d103f2a2e6d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* y_array_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a character array and initializes all elements to zero As <a class="el" href="group__core.html#ga71b54880fd4fe004b3cb8141255c6474" title="Ylib wrapper for malloc() ">y_mem_alloc()</a>, but using the '<a class="el" href="group__memory.html#gae201ae1031fe85000b4e22abb3a824b2" title="Documented at http://www.cplusplus.com/reference/cstdlib/calloc/. ">calloc</a>' function, rather than '<a class="el" href="group__memory.html#ga5f1a5df9b8c50bd259b8c34c0056e304" title="Documented at http://www.cplusplus.com/reference/cstdlib/malloc/. ">malloc()</a>'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Expected number of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>How much space a single character requires. Usually this should contain "sizeof char". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pre-zeroed block of memory of the requisite size allocated using <a class="el" href="group__memory.html#gae201ae1031fe85000b4e22abb3a824b2" title="Documented at http://www.cplusplus.com/reference/cstdlib/calloc/. ">calloc()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The memory resulting from this call will need to be freed using <a class="el" href="group__memory.html#ga557a44efb227bec48c165bf5e016b675" title="Documented at http://www.cplusplus.com/reference/cstdlib/free/. ">free()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga71b54880fd4fe004b3cb8141255c6474" title="Ylib wrapper for malloc() ">y_mem_alloc()</a>, <a class="el" href="group__memory.html#gae201ae1031fe85000b4e22abb3a824b2" title="Documented at http://www.cplusplus.com/reference/cstdlib/calloc/. ">calloc()</a> </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00245">245</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga319710d6642f34a8ea51a1a9898869fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double y_drand </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random number between 0 &lt;= <a class="el" href="group__core.html#ga319710d6642f34a8ea51a1a9898869fc" title="Generate a random number between 0 &lt;= y_drand() &lt; 1. This supersedes y_rand().  Equal to Math...">y_drand()</a> &lt; 1. This supersedes <a class="el" href="group__core.html#ga0419985b32761cce3f5d75e6aad36f05" title="Generate a random (integer) number between 0 and Y_RAND_MAX (30 bit maxint). ">y_rand()</a>. <br />
Equal to Math.random in Java and JavaScript, Random.NextDouble in C#, etc. Better distribution of the random numbers over the range than by using <a class="el" href="group__core.html#ga0419985b32761cce3f5d75e6aad36f05" title="Generate a random (integer) number between 0 and Y_RAND_MAX (30 bit maxint). ">y_rand()</a> with modulo (%) &ndash; thus no skewed results. </p>
<dl class="section return"><dt>Returns</dt><dd>Random number between 0 and 1 (exclusive). Accuracy: 9.4 digits (32 bits) thus increments of approx. 2.3e-10.</dd></dl>
<p><b>Examples:</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if (y_drand() &lt; 0.123) ... -&gt; change 12.3% true</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;double value = min + y_drand() * (max - min); // to range example</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int value = min + y_drand() * (max - min + 1); // for min &lt;= value &lt;= max</div></div><!-- fragment --> <dl class="section author"><dt>Author</dt><dd>A.U. Luyer </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00189">189</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8252a459f15c52a8680fff9ddbd7356c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* y_get_parameter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the content of a parameter and return it as a char *. </p>
<p>This is useful mostly for code that wants to manipulate parameter contents but not care about the name of the parameter itself. (Something which applies to most of ylib ..)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param_name</td><td>The name of the parameter to fetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A char* buffer containing the contents of the parameter, allocated by lr_eval_string(). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This returns memory allocated by lr_eval_string(). It is freed at the end of the iteration.</dd></dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char *test;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;lr_save_string(&quot;test123&quot;, &quot;TestParam&quot;);        // save the string &quot;test123&quot; into parameter {TestParam}</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;test=y_get_parameter(&quot;TestParam&quot;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;lr_message(&quot;Test: %s&quot;, test);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#gac0778c8b8f3da732862ab82176857be8" title="Test if the given parameter is empty or not yet set. (These are two different things..) It would be nice if loadrunner had a builtin for this. ">y_is_empty_parameter()</a>, <a class="el" href="group__core.html#gaa80c4db4c75cdc0c03aad6f69b3dff3c" title="Get the content of a parameter and return it as a char * (lr_eval_string_ext() version) ...">y_get_parameter_ext()</a>, <a class="el" href="group__core.html#gaf81efb56d5afc4806cdc79f64ba3d675" title="Get the content of a parameter and return it as a char *, or return NULL if it wasn&#39;t set...">y_get_parameter_or_null()</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Floris Kraak </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00336">336</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab903d513f84dc0cd3f7af7acf67e2fb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* y_get_parameter_eval_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the string required to fetch the contents of a parameter through lr_eval_string(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param_name</td><td>The parameter name to construct the eval text for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a char* allocated with <a class="el" href="group__core.html#ga71b54880fd4fe004b3cb8141255c6474" title="Ylib wrapper for malloc() ">y_mem_alloc()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The return argument will need to be freed via a call to <a class="el" href="group__memory.html#ga557a44efb227bec48c165bf5e016b675" title="Documented at http://www.cplusplus.com/reference/cstdlib/free/. ">free()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga8252a459f15c52a8680fff9ddbd7356c" title="Get the content of a parameter and return it as a char *. ">y_get_parameter()</a>, <a class="el" href="group__core.html#gaa80c4db4c75cdc0c03aad6f69b3dff3c" title="Get the content of a parameter and return it as a char * (lr_eval_string_ext() version) ...">y_get_parameter_ext()</a>, <a class="el" href="group__core.html#gaf81efb56d5afc4806cdc79f64ba3d675" title="Get the content of a parameter and return it as a char *, or return NULL if it wasn&#39;t set...">y_get_parameter_or_null()</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Floris Kraak </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00287">287</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaa80c4db4c75cdc0c03aad6f69b3dff3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* y_get_parameter_ext </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source_param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the content of a parameter and return it as a char * (lr_eval_string_ext() version) </p>
<p>Like y_get_parameter, but the result will use lr_eval_string_ext() to acquire it's memory, rather than getting it from lr_eval_string. This can be useful when you want your data to remain in memory instead of getting freed at the end of each iteration. An example is the browser emulation code in y_emulate_browser.c, which sets up a linked list that has to stay allocated throughout the duration of the test. (And therefore never needs to be freed. But I digress.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_param</td><td>The name of the parameter to fetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A char* buffer containing the contents of the parameter, allocated with lr_eval_string_ext() </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Memory allocated in this manner must be freed using lr_eval_string_ext_free() or it will linger.</dd></dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char *test;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;lr_save_string(&quot;test123&quot;, &quot;TestParam&quot;);        // save the string &quot;test123&quot; into parameter {TestParam}</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;test=y_get_parameter_ext(&quot;TestParam&quot;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;lr_message(&quot;Test: %s&quot;, test);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;lr_eval_string_ext_free(test);</div></div><!-- fragment --> <dl class="section author"><dt>Author</dt><dd>Floris Kraak </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga8252a459f15c52a8680fff9ddbd7356c" title="Get the content of a parameter and return it as a char *. ">y_get_parameter()</a>, lr_eval_string_ext() </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00441">441</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf81efb56d5afc4806cdc79f64ba3d675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* y_get_parameter_or_null </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the content of a parameter and return it as a char *, or return NULL if it wasn't set. </p>
<p>This will return null in the most typical case: A parameter saved with web_reg_save_param(), but never filled. The actual check employed here is a test that looks if the parameter content matches the parameter name surrounded by brackets.</p>
<p>If the parameter was never filled, lr_eval_string() will return that. However, in many more elaborate cases we really need to know if it was never filled to begin with. This function mimics the behaviour we really want to see in LR, but don't have. (At least, not in LR 11.05, the version I'm working with.)</p>
<p>It would be really nice if there was a loadrunner built-in that did this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param_name</td><td>The name of the parameter to fetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A char* buffer containing the contents of the parameter, allocated by lr_eval_string(), or NULL. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This returns memory allocated by lr_eval_string(). It is likely to disappear (get freed) at the end of the iteration. </dd>
<dd>
If the content of the parameter matches the name of the parameter surrounded by brackets this function will return NULL even if it's not empty.</dd></dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char *test;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;lr_save_string(&quot;test123&quot;, &quot;TestParam&quot;);        // save the string &quot;test123&quot; into parameter {TestParam}</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;test=y_get_parameter(&quot;TestParam&quot;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;lr_message(&quot;Test: %s&quot;, test);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga8252a459f15c52a8680fff9ddbd7356c" title="Get the content of a parameter and return it as a char *. ">y_get_parameter()</a>, <a class="el" href="group__core.html#gac0778c8b8f3da732862ab82176857be8" title="Test if the given parameter is empty or not yet set. (These are two different things..) It would be nice if loadrunner had a builtin for this. ">y_is_empty_parameter()</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Floris Kraak </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00373">373</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac0c6a383cf2934da4acc1451a1cdea21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* y_get_parameter_with_malloc_or_null </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src_param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the content of a parameter and return it as a char * (malloc version) </p>
<p>This is like <a class="el" href="group__core.html#ga8252a459f15c52a8680fff9ddbd7356c" title="Get the content of a parameter and return it as a char *. ">y_get_parameter()</a>, but the result will use memory allocated with <a class="el" href="group__core.html#ga71b54880fd4fe004b3cb8141255c6474" title="Ylib wrapper for malloc() ">y_mem_alloc()</a>, instead of acquired from lr_eval_string().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src_param</td><td>The name of the parameter to fetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A char* buffer containing the contents of the parameter, allocated with <a class="el" href="group__core.html#ga71b54880fd4fe004b3cb8141255c6474" title="Ylib wrapper for malloc() ">y_mem_alloc()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Memory allocated in this manner must be freed using <a class="el" href="group__memory.html#ga557a44efb227bec48c165bf5e016b675" title="Documented at http://www.cplusplus.com/reference/cstdlib/free/. ">free()</a> or it will linger.</dd></dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char *test;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;lr_save_string(&quot;test123&quot;, &quot;TestParam&quot;);        // save the string &quot;test123&quot; into parameter {TestParam}</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;test=y_get_parameter_in_malloc_string(&quot;TestParam&quot;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;lr_message(&quot;Test: %s&quot;, test);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;free(test);</div></div><!-- fragment --> <dl class="section author"><dt>Author</dt><dd>Floris Kraak </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00406">406</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac0778c8b8f3da732862ab82176857be8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int y_is_empty_parameter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the given parameter is empty or not yet set. (These are two different things..) It would be nice if loadrunner had a builtin for this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param_name</td><td>The name of the parameter to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero (true) if the parameter is empty, zero (false) otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#gab903d513f84dc0cd3f7af7acf67e2fb2" title="Obtain the string required to fetch the contents of a parameter through lr_eval_string(). ">y_get_parameter_eval_string()</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Floris Kraak </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00305">305</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga71b54880fd4fe004b3cb8141255c6474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* y_mem_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ylib wrapper for <a class="el" href="group__memory.html#ga5f1a5df9b8c50bd259b8c34c0056e304" title="Documented at http://www.cplusplus.com/reference/cstdlib/malloc/. ">malloc()</a> </p>
<p>Allocates a block of memory, but aborts the Vuser if that fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The memory resulting from this call will need to be freed using <a class="el" href="group__memory.html#ga557a44efb227bec48c165bf5e016b675" title="Documented at http://www.cplusplus.com/reference/cstdlib/free/. ">free()</a>.</dd></dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char *example_string = &quot;some_text&quot;;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;int size = strlen(example_string)+1;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;char *example_string_copy = y_mem_alloc(size);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;snprintf(example_string_copy, size, &quot;%s&quot;, example_string);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;lr_log_message(&quot;Copy of example string contains: %s&quot;, example_string_copy);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;free(example_string_copy);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga084a530700465b1a7a10d103f2a2e6d4" title="Allocates a character array and initializes all elements to zero As y_mem_alloc(), but using the &#39;calloc&#39; function, rather than &#39;malloc()&#39;. ">y_array_alloc()</a>, <a class="el" href="group__memory.html#ga5f1a5df9b8c50bd259b8c34c0056e304" title="Documented at http://www.cplusplus.com/reference/cstdlib/malloc/. ">malloc()</a> </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00221">221</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0419985b32761cce3f5d75e6aad36f05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long y_rand </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random (integer) number between 0 and Y_RAND_MAX (30 bit maxint). </p>
<dl class="section return"><dt>Returns</dt><dd>Random number (integer) between 0 and Y_RAND_MAX: 30-bit maxint - slightly over 1 billion. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Superseded by <a class="el" href="group__core.html#ga319710d6642f34a8ea51a1a9898869fc" title="Generate a random number between 0 &lt;= y_drand() &lt; 1. This supersedes y_rand().  Equal to Math...">y_drand</a></dd></dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int random_number;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;random_number=y_rand();</div></div><!-- fragment --> <dl class="section author"><dt>Author</dt><dd>Floris Kraak </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Superseded by <a class="el" href="group__core.html#ga319710d6642f34a8ea51a1a9898869fc" title="Generate a random number between 0 &lt;= y_drand() &lt; 1. This supersedes y_rand().  Equal to Math...">y_drand</a> </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00156">156</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7350ca6bb0383b2169ef4eaae3b091e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void y_setup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ylib setup - determines and stores the identity of the virtual user. </p>
<p>This runs lr_whoami and sets y_virtual_user_id and y_virtual_user_group as global variables. Called <a class="el" href="group__core.html#ga0419985b32761cce3f5d75e6aad36f05" title="Generate a random (integer) number between 0 and Y_RAND_MAX (30 bit maxint). ">y_rand()</a> (for it's seed), <a class="el" href="group__core.html#gaed34897cb0a5fb0ae18cf0d6facc35b5" title="Test if this script is running in vugen (debug mode) ">y_is_vugen_run()</a> and others dynamically.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Only call this if you need the y_virtual_user_id and y_virtual_group variables to be set. Ylib functions that need this will call it when required. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga0419985b32761cce3f5d75e6aad36f05" title="Generate a random (integer) number between 0 and Y_RAND_MAX (30 bit maxint). ">y_rand()</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Floris Kraak </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00085">85</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8cba325c05b63bbbdc499702c4f5c6e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* y_strdup </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string into a <a class="el" href="group__memory.html#ga5f1a5df9b8c50bd259b8c34c0056e304" title="Documented at http://www.cplusplus.com/reference/cstdlib/malloc/. ">malloc</a>'d piece of memory using <a class="el" href="group__string.html#ga86e0df1bf9e434074f958434e0af7581" title="Documented at http://pubs.opengroup.org/onlinepubs/007904975/functions/strdup.html ...">strdup()</a>, and lr_abort() if the allocation fails. See the <a class="el" href="group__string.html#ga86e0df1bf9e434074f958434e0af7581" title="Documented at http://pubs.opengroup.org/onlinepubs/007904975/functions/strdup.html ...">strdup()</a> C documentation for what it does. This is just a simple wrapper around it that catches the strdup return value and handles any errors by aborting the script. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the string, allocated via <a class="el" href="group__string.html#ga86e0df1bf9e434074f958434e0af7581" title="Documented at http://pubs.opengroup.org/onlinepubs/007904975/functions/strdup.html ...">strdup()</a>. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Floris Kraak </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00268">268</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga6946e1e353167a7a711e3ddcb8a39b6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int y_is_vugen_run_bool = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean, true when running in Vugen. Not able to do this in pre-compile phase. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga7350ca6bb0383b2169ef4eaae3b091e7" title="Ylib setup - determines and stores the identity of the virtual user. ">y_setup()</a> </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00046">46</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ebd23898db36692c02dd58d9649f4a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int y_scid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The virtual user scid, as reported by lr_whoami(). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga7350ca6bb0383b2169ef4eaae3b091e7" title="Ylib setup - determines and stores the identity of the virtual user. ">y_setup()</a> </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00044">44</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga36fcd2d9a92671f11bfebf8b7bfa34ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* y_virtual_user_group = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The virtual user group, as reported by lr_whoami(). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga7350ca6bb0383b2169ef4eaae3b091e7" title="Ylib setup - determines and stores the identity of the virtual user. ">y_setup()</a> </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00042">42</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga312065213820734af47b86c233a26c0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int y_virtual_user_id = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The virtual user id, as reported by lr_whoami(). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga7350ca6bb0383b2169ef4eaae3b091e7" title="Ylib setup - determines and stores the identity of the virtual user. ">y_setup()</a> </dd></dl>

<p>Definition at line <a class="el" href="y__core_8c_source.html#l00040">40</a> of file <a class="el" href="y__core_8c_source.html">y_core.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
